#include <iostream>
using namespace std;

class MyClass {
public:
    int *data;

    MyClass(int size) {
        this->Size = size; // для того чтобы помнить какого размера наш массив (для конструктора копирования)
        cout << "Вызвался конструктор " << this << endl;
        this->data = new int[size];
        for (int i = 0; i < size; ++i) {
            data[i] = i;
        }
    }
    // Конструктор копирования (заменяет конструктор копирования по умолчанию)
    MyClass(const MyClass &other) { // обьект который копируем - это other (поэтому он принимается по ссылке)
        cout << "Вызвался конструктор копирования " << this << endl;
        this->Size = other.Size; // копируем поле от исходного обьекта
        this->data = new int[other.Size]; // создаем массив data нового обьекта с размером Size из копируемого обьекта
        for (int i = 0; i < other.Size; ++i) {
            this->data[i] = other.data[i]; // копируем массив из старого обьекта (other) в нвоый
        }
    }
    // Перегрузка оператора присваивания
    MyClass &operator = (const MyClass &other) { // ссылка, т.к. нужно всего лишь посомтреть что в этом обьекте, а не копировать
        // его. А const для безопасности, т.к. мы ничего не меняем через ссылку
        cout << "Вызвался оператор = " << this << endl;
        this->Size = other.Size; // т.к. поле Size не выделено в динамической памяти, его очищать не нужно
        if (this-> data != nullptr) { // проверка чтобы не удалить случайные данные из-за того что массива еще нету
            delete[] this-> data; // если массив уже создан, тогда удалить его из памяти
        }
        this->data = new int[other.Size]; // создаем массив data нового обьекта с размером Size из копируемого обьекта
        for (int i = 0; i < other.Size; ++i) {
            this->data[i] = other.data[i]; // копируем массив из старого обьекта (other) в нвоый
        }
        cout  << endl;
        return *this; // this - это указатель, а не ссылка, а наш тип возвращаемтого значения - сслыка
    }

    ~MyClass() {
        cout << "Вызвался деструктор " << this << endl;
        delete[] data;
    }
private:
    int Size;
};

void Foo(MyClass value) {
    cout << "Вызвалась функция Foo" << endl;
}

MyClass Foo2() {
    cout << "Вызвалась функция Foo2" << endl;
    MyClass temp(2);
    return temp;
}

int main() {
    // Вся суть в том, что конструктор копирования по умолчанию ИДЕНТИЧНО копирует обьект, следовательно абсолютно
    // идентично копируются и ПОЛЯ класса, а значит data указывает на один и тот же динамический массив, а значит после
    // вызова деструктора первого обьекта, очистится область памяти хранящяя массив, НО второй указатель со второго
    // обькета все еще будет указывать на ту область памяти, в которой уже может хранится в принципе все что угодно,
    // и деструктор второго обьекта попытается удалить это! Можно сказать что мы попытались 2 раза освободить данные из
    // одной и той же области памяти
    MyClass a(2);
    MyClass b(a); // неявное копировнаие
//    Foo(a);
//    Foo2();

    // Перегрузка операторов присваивания
    MyClass c(10);
    MyClass d(2);
    c = d;
    return 0;
}